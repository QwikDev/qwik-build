const QWIK_LOADER = "const t=document,e=window,n=new Set,o=new Set([t]);let r;const s=(t,e)=>Array.from(t.querySelectorAll(e)),i=t=>{const e=[];return o.forEach((n=>e.push(...s(n,t)))),e},a=t=>{g(t),s(t,\"[q\\\\:shadowroot]\").forEach((t=>{const e=t.shadowRoot;e&&a(e)}))},c=t=>t&&\"function\"==typeof t.then;let l=!0;const f=(t,e,n=e.type)=>{let o=l;i(\"[on\"+t+\"\\\\:\"+n+\"]\").forEach((r=>{o=!0,b(r,t,e,n)})),o||window[t.slice(1)].removeEventListener(n,\"-window\"===t?d:_)},p=e=>{if(void 0===e._qwikjson_){let n=(e===t.documentElement?t.body:e).lastElementChild;for(;n;){if(\"SCRIPT\"===n.tagName&&\"qwik/json\"===n.getAttribute(\"type\")){e._qwikjson_=JSON.parse(n.textContent.replace(/\\\\x3C(\\/?script)/gi,\"<$1\"));break}n=n.previousElementSibling}}},u=(t,e)=>new CustomEvent(t,{detail:e}),b=async(e,n,o,r=o.type)=>{const s=\"on\"+n+\":\"+r;e.hasAttribute(\"preventdefault:\"+r)&&o.preventDefault(),e.hasAttribute(\"stoppropagation:\"+r)&&o.stopPropagation();const i=e._qc_,a=i&&i.li.filter((t=>t[0]===s));if(a&&a.length>0){for(const t of a){const n=t[1].getFn([e,o],(()=>e.isConnected))(o,e),r=o.cancelBubble;c(n)&&await n,r&&o.stopPropagation()}return}const l=e.getAttribute(s);if(l){const n=e.closest(\"[q\\\\:container]\"),r=n.getAttribute(\"q:base\"),s=n.getAttribute(\"q:version\")||\"unknown\",i=n.getAttribute(\"q:manifest-hash\")||\"dev\",a=new URL(r,t.baseURI);for(const f of l.split(\"\\n\")){const l=new URL(f,a),u=l.href,b=l.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",q=performance.now();let _,d,w;const m=f.startsWith(\"#\"),y={qBase:r,qManifest:i,qVersion:s,href:u,symbol:b,element:e,reqTime:q};if(m){const e=n.getAttribute(\"q:instance\");_=(t[\"qFuncs_\"+e]||[])[Number.parseInt(b)],_||(d=\"sync\",w=Error(\"sym:\"+b))}else{h(\"qsymbol\",y);const t=l.href.split(\"#\")[0];try{const e=import(t);p(n),_=(await e)[b],_||(d=\"no-symbol\",w=Error(`${b} not in ${t}`))}catch(t){d||(d=\"async\"),w=t}}if(!_){h(\"qerror\",{importError:d,error:w,...y}),console.error(w);break}const g=t.__q_context__;if(e.isConnected)try{t.__q_context__=[e,o,l];const n=_(o,e);c(n)&&await n}catch(t){h(\"qerror\",{error:t,...y})}finally{t.__q_context__=g}}}},h=(e,n)=>{t.dispatchEvent(u(e,n))},q=t=>t.replace(/([A-Z])/g,(t=>\"-\"+t.toLowerCase())),_=async t=>{let e=q(t.type),n=t.target;for(f(\"-document\",t,e);n&&n.getAttribute;){const o=b(n,\"\",t,e);let r=t.cancelBubble;c(o)&&await o,r||(r=r||t.cancelBubble||n.hasAttribute(\"stoppropagation:\"+t.type)),n=t.bubbles&&!0!==r?n.parentElement:null}},d=t=>{f(\"-window\",t,q(t.type))},w=()=>{var s;const c=t.readyState;if(!r&&(\"interactive\"==c||\"complete\"==c)&&(o.forEach(a),r=1,h(\"qinit\"),(null!=(s=e.requestIdleCallback)?s:e.setTimeout).bind(e)((()=>h(\"qidle\"))),n.has(\"qvisible\"))){const t=i(\"[on\\\\:qvisible]\"),e=new IntersectionObserver((t=>{for(const n of t)n.isIntersecting&&(e.unobserve(n.target),b(n.target,\"\",u(\"qvisible\",n)))}));t.forEach((t=>e.observe(t)))}},m=(t,e,n,o=!1)=>{t.addEventListener(e,n,{capture:o,passive:!1})};let y;const g=(...t)=>{l=!0,clearTimeout(y),y=setTimeout((()=>l=!1),2e4);for(const r of t)\"string\"==typeof r?n.has(r)||(o.forEach((t=>m(t,r,_,!0))),m(e,r,d,!0),n.add(r)):o.has(r)||(n.forEach((t=>m(r,t,_,!0))),o.add(r))};if(!(\"__q_context__\"in t)){t.__q_context__=0;const r=e.qwikevents;r&&(Array.isArray(r)?g(...r):g(\"click\",\"input\")),e.qwikevents={events:n,roots:o,push:g},m(t,\"readystatechange\",w),w()}";
const QWIK_LOADER_DEBUG = "const doc = document;\nconst win = window;\nconst events = /* @__PURE__ */ new Set();\nconst roots = /* @__PURE__ */ new Set([doc]);\nlet hasInitialized;\nconst nativeQuerySelectorAll = (root, selector) => Array.from(root.querySelectorAll(selector));\nconst querySelectorAll = (query) => {\n  const elements = [];\n  roots.forEach((root) => elements.push(...nativeQuerySelectorAll(root, query)));\n  return elements;\n};\nconst findShadowRoots = (fragment) => {\n  processEventOrNode(fragment);\n  nativeQuerySelectorAll(fragment, \"[q\\\\:shadowroot]\").forEach((parent) => {\n    const shadowRoot = parent.shadowRoot;\n    shadowRoot && findShadowRoots(shadowRoot);\n  });\n};\nconst isPromise = (promise) => promise && typeof promise.then === \"function\";\nlet doNotClean = true;\nconst broadcast = (infix, ev, type = ev.type) => {\n  let found = doNotClean;\n  querySelectorAll(\"[on\" + infix + \"\\\\:\" + type + \"]\").forEach((el) => {\n    found = true;\n    dispatch(el, infix, ev, type);\n  });\n  if (!found) {\n    window[infix.slice(1)].removeEventListener(\n      type,\n      infix === \"-window\" ? processWindowEvent : processDocumentEvent\n    );\n  }\n};\nconst resolveContainer = (containerEl) => {\n  if (containerEl._qwikjson_ === void 0) {\n    const parentJSON = containerEl === doc.documentElement ? doc.body : containerEl;\n    let script = parentJSON.lastElementChild;\n    while (script) {\n      if (script.tagName === \"SCRIPT\" && script.getAttribute(\"type\") === \"qwik/json\") {\n        containerEl._qwikjson_ = JSON.parse(\n          script.textContent.replace(/\\\\x3C(\\/?script)/gi, \"<$1\")\n        );\n        break;\n      }\n      script = script.previousElementSibling;\n    }\n  }\n};\nconst createEvent = (eventName, detail) => new CustomEvent(eventName, {\n  detail\n});\nconst dispatch = async (element, onPrefix, ev, eventName = ev.type) => {\n  const attrName = \"on\" + onPrefix + \":\" + eventName;\n  if (element.hasAttribute(\"preventdefault:\" + eventName)) {\n    ev.preventDefault();\n  }\n  if (element.hasAttribute(\"stoppropagation:\" + eventName)) {\n    ev.stopPropagation();\n  }\n  const ctx = element._qc_;\n  const relevantListeners = ctx && ctx.li.filter((li) => li[0] === attrName);\n  if (relevantListeners && relevantListeners.length > 0) {\n    for (const listener of relevantListeners) {\n      const results = listener[1].getFn([element, ev], () => element.isConnected)(ev, element);\n      const cancelBubble = ev.cancelBubble;\n      if (isPromise(results)) {\n        await results;\n      }\n      if (cancelBubble) {\n        ev.stopPropagation();\n      }\n    }\n    return;\n  }\n  const attrValue = element.getAttribute(attrName);\n  if (attrValue) {\n    const container = element.closest(\"[q\\\\:container]\");\n    const qBase = container.getAttribute(\"q:base\");\n    const qVersion = container.getAttribute(\"q:version\") || \"unknown\";\n    const qManifest = container.getAttribute(\"q:manifest-hash\") || \"dev\";\n    const base = new URL(qBase, doc.baseURI);\n    for (const qrl of attrValue.split(\"\\n\")) {\n      const url = new URL(qrl, base);\n      const href = url.href;\n      const symbol = url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\n      const reqTime = performance.now();\n      let handler;\n      let importError;\n      let error;\n      const isSync = qrl.startsWith(\"#\");\n      const eventData = {\n        qBase,\n        qManifest,\n        qVersion,\n        href,\n        symbol,\n        element,\n        reqTime\n      };\n      if (isSync) {\n        const hash = container.getAttribute(\"q:instance\");\n        handler = (doc[\"qFuncs_\" + hash] || [])[Number.parseInt(symbol)];\n        if (!handler) {\n          importError = \"sync\";\n          error = new Error(\"sym:\" + symbol);\n        }\n      } else {\n        emitEvent(\"qsymbol\", eventData);\n        const uri = url.href.split(\"#\")[0];\n        try {\n          const module = import(\n                        uri\n          );\n          resolveContainer(container);\n          handler = (await module)[symbol];\n          if (!handler) {\n            importError = \"no-symbol\";\n            error = new Error(`${symbol} not in ${uri}`);\n          }\n        } catch (err) {\n          importError || (importError = \"async\");\n          error = err;\n        }\n      }\n      if (!handler) {\n        emitEvent(\"qerror\", {\n          importError,\n          error,\n          ...eventData\n        });\n        console.error(error);\n        break;\n      }\n      const previousCtx = doc.__q_context__;\n      if (element.isConnected) {\n        try {\n          doc.__q_context__ = [element, ev, url];\n          const results = handler(ev, element);\n          if (isPromise(results)) {\n            await results;\n          }\n        } catch (error2) {\n          emitEvent(\"qerror\", { error: error2, ...eventData });\n        } finally {\n          doc.__q_context__ = previousCtx;\n        }\n      }\n    }\n  }\n};\nconst emitEvent = (eventName, detail) => {\n  doc.dispatchEvent(createEvent(eventName, detail));\n};\nconst camelToKebab = (str) => str.replace(/([A-Z])/g, (a) => \"-\" + a.toLowerCase());\nconst processDocumentEvent = async (ev) => {\n  let type = camelToKebab(ev.type);\n  let element = ev.target;\n  broadcast(\"-document\", ev, type);\n  while (element && element.getAttribute) {\n    const results = dispatch(element, \"\", ev, type);\n    let cancelBubble = ev.cancelBubble;\n    if (isPromise(results)) {\n      await results;\n    }\n    cancelBubble || (cancelBubble = cancelBubble || ev.cancelBubble || element.hasAttribute(\"stoppropagation:\" + ev.type));\n    element = ev.bubbles && cancelBubble !== true ? element.parentElement : null;\n  }\n};\nconst processWindowEvent = (ev) => {\n  broadcast(\"-window\", ev, camelToKebab(ev.type));\n};\nconst processReadyStateChange = () => {\n  var _a;\n  const readyState = doc.readyState;\n  if (!hasInitialized && (readyState == \"interactive\" || readyState == \"complete\")) {\n    roots.forEach(findShadowRoots);\n    hasInitialized = 1;\n    emitEvent(\"qinit\");\n    const riC = (_a = win.requestIdleCallback) != null ? _a : win.setTimeout;\n    riC.bind(win)(() => emitEvent(\"qidle\"));\n    if (events.has(\"qvisible\")) {\n      const results = querySelectorAll(\"[on\\\\:qvisible]\");\n      const observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            observer.unobserve(entry.target);\n            dispatch(entry.target, \"\", createEvent(\"qvisible\", entry));\n          }\n        }\n      });\n      results.forEach((el) => observer.observe(el));\n    }\n  }\n};\nconst addEventListener = (el, eventName, handler, capture = false) => {\n  el.addEventListener(eventName, handler, { capture, passive: false });\n};\nlet cleanTimer;\nconst processEventOrNode = (...eventNames) => {\n  doNotClean = true;\n  clearTimeout(cleanTimer);\n  cleanTimer = setTimeout(() => doNotClean = false, 2e4);\n  for (const eventNameOrNode of eventNames) {\n    if (typeof eventNameOrNode === \"string\") {\n      if (!events.has(eventNameOrNode)) {\n        roots.forEach(\n          (root) => addEventListener(root, eventNameOrNode, processDocumentEvent, true)\n        );\n        addEventListener(win, eventNameOrNode, processWindowEvent, true);\n        events.add(eventNameOrNode);\n      }\n    } else {\n      if (!roots.has(eventNameOrNode)) {\n        events.forEach(\n          (eventName) => addEventListener(eventNameOrNode, eventName, processDocumentEvent, true)\n        );\n        roots.add(eventNameOrNode);\n      }\n    }\n  }\n};\nif (!(\"__q_context__\" in doc)) {\n  doc.__q_context__ = 0;\n  const qwikevents = win.qwikevents;\n  if (qwikevents) {\n    if (Array.isArray(qwikevents)) {\n      processEventOrNode(...qwikevents);\n    } else {\n      processEventOrNode(\"click\", \"input\");\n    }\n  }\n  win.qwikevents = {\n    events,\n    roots,\n    push: processEventOrNode\n  };\n  addEventListener(doc, \"readystatechange\", processReadyStateChange);\n  processReadyStateChange();\n}";
export { QWIK_LOADER, QWIK_LOADER_DEBUG };
