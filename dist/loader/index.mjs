const QWIK_LOADER = "(()=>{const t=document,e=window,n=new Set,o=new Set([t]);let r;const s=(t,e)=>Array.from(t.querySelectorAll(e)),a=t=>{const e=[];return o.forEach((n=>e.push(...s(n,t)))),e},i=t=>{w(t),s(t,\"[q\\\\:shadowroot]\").forEach((t=>{const e=t.shadowRoot;e&&i(e)}))},c=t=>t&&\"function\"==typeof t.then,l=(t,e,n=e.type)=>{a(\"[on\"+t+\"\\\\:\"+n+\"]\").forEach((o=>b(o,t,e,n)))},f=e=>{if(void 0===e._qwikjson_){let n=(e===t.documentElement?t.body:e).lastElementChild;for(;n;){if(\"SCRIPT\"===n.tagName&&\"qwik/json\"===n.getAttribute(\"type\")){e._qwikjson_=JSON.parse(n.textContent.replace(/\\\\x3C(\\/?script)/gi,\"<$1\"));break}n=n.previousElementSibling}}},p=(t,e)=>new CustomEvent(t,{detail:e}),b=async(e,n,o,r=o.type)=>{const s=\"on\"+n+\":\"+r;e.hasAttribute(\"preventdefault:\"+r)&&o.preventDefault(),e.hasAttribute(\"stoppropagation:\"+r)&&o.stopPropagation();const a=e._qc_,i=a&&a.li.filter((t=>t[0]===s));if(i&&i.length>0){for(const t of i){const n=t[1].getFn([e,o],(()=>e.isConnected))(o,e),r=o.cancelBubble;c(n)&&await n,r&&o.stopPropagation()}return}const l=e.getAttribute(s);if(l){const n=e.closest(\"[q\\\\:container]\"),r=n.getAttribute(\"q:base\"),s=n.getAttribute(\"q:version\")||\"unknown\",a=n.getAttribute(\"q:manifest-hash\")||\"dev\",i=new URL(r,t.baseURI);for(const p of l.split(\"\\n\")){const l=new URL(p,i),b=l.href,h=l.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",q=performance.now();let _,d,y;const w=p.startsWith(\"#\"),g={qBase:r,qManifest:a,qVersion:s,href:b,symbol:h,element:e,reqTime:q};if(w){const e=n.getAttribute(\"q:instance\");_=(t[\"qFuncs_\"+e]||[])[Number.parseInt(h)],_||(d=\"sync\",y=Error(\"sym:\"+h))}else{u(\"qsymbol\",g);const t=l.href.split(\"#\")[0];try{const e=import(t);f(n),_=(await e)[h],_||(d=\"no-symbol\",y=Error(`${h} not in ${t}`))}catch(t){d||(d=\"async\"),y=t}}if(!_){u(\"qerror\",{importError:d,error:y,...g}),console.error(y);break}const m=t.__q_context__;if(e.isConnected)try{t.__q_context__=[e,o,l];const n=_(o,e);c(n)&&await n}catch(t){u(\"qerror\",{error:t,...g})}finally{t.__q_context__=m}}}},u=(e,n)=>{t.dispatchEvent(p(e,n))},h=t=>t.replace(/([A-Z])/g,(t=>\"-\"+t.toLowerCase())),q=async t=>{let e=h(t.type),n=t.target;for(l(\"-document\",t,e);n&&n.getAttribute;){const o=b(n,\"\",t,e);let r=t.cancelBubble;c(o)&&await o,r=r||t.cancelBubble||n.hasAttribute(\"stoppropagation:\"+t.type),n=t.bubbles&&!0!==r?n.parentElement:null}},_=t=>{l(\"-window\",t,h(t.type))},d=()=>{var s;const c=t.readyState;if(!r&&(\"interactive\"==c||\"complete\"==c)&&(o.forEach(i),r=1,u(\"qinit\"),(null!=(s=e.requestIdleCallback)?s:e.setTimeout).bind(e)((()=>u(\"qidle\"))),n.has(\"qvisible\"))){const t=a(\"[on\\\\:qvisible]\"),e=new IntersectionObserver((t=>{for(const n of t)n.isIntersecting&&(e.unobserve(n.target),b(n.target,\"\",p(\"qvisible\",n)))}));t.forEach((t=>e.observe(t)))}},y=(t,e,n,o=!1)=>t.addEventListener(e,n,{capture:o,passive:!1}),w=(...t)=>{for(const r of t)\"string\"==typeof r?n.has(r)||(o.forEach((t=>y(t,r,q,!0))),y(e,r,_,!0),n.add(r)):o.has(r)||(n.forEach((t=>y(r,t,q,!0))),o.add(r))};if(!(\"__q_context__\"in t)){t.__q_context__=0;const r=e.qwikevents;Array.isArray(r)&&w(...r),e.qwikevents={events:n,roots:o,push:w},y(t,\"readystatechange\",d),d()}})()";
const QWIK_LOADER_DEBUG = "(() => {\n  const doc = document;\n  const win = window;\n  const events = /* @__PURE__ */ new Set();\n  const roots = /* @__PURE__ */ new Set([doc]);\n  let hasInitialized;\n  const nativeQuerySelectorAll = (root, selector) => Array.from(root.querySelectorAll(selector));\n  const querySelectorAll = (query) => {\n    const elements = [];\n    roots.forEach((root) => elements.push(...nativeQuerySelectorAll(root, query)));\n    return elements;\n  };\n  const findShadowRoots = (fragment) => {\n    processEventOrNode(fragment);\n    nativeQuerySelectorAll(fragment, \"[q\\\\:shadowroot]\").forEach((parent) => {\n      const shadowRoot = parent.shadowRoot;\n      shadowRoot && findShadowRoots(shadowRoot);\n    });\n  };\n  const isPromise = (promise) => promise && typeof promise.then === \"function\";\n  const broadcast = (infix, ev, type = ev.type) => {\n    querySelectorAll(\"[on\" + infix + \"\\\\:\" + type + \"]\").forEach(\n      (el) => dispatch(el, infix, ev, type)\n    );\n  };\n  const resolveContainer = (containerEl) => {\n    if (containerEl._qwikjson_ === void 0) {\n      const parentJSON = containerEl === doc.documentElement ? doc.body : containerEl;\n      let script = parentJSON.lastElementChild;\n      while (script) {\n        if (script.tagName === \"SCRIPT\" && script.getAttribute(\"type\") === \"qwik/json\") {\n          containerEl._qwikjson_ = JSON.parse(\n            script.textContent.replace(/\\\\x3C(\\/?script)/gi, \"<$1\")\n          );\n          break;\n        }\n        script = script.previousElementSibling;\n      }\n    }\n  };\n  const createEvent = (eventName, detail) => new CustomEvent(eventName, {\n    detail\n  });\n  const dispatch = async (element, onPrefix, ev, eventName = ev.type) => {\n    const attrName = \"on\" + onPrefix + \":\" + eventName;\n    if (element.hasAttribute(\"preventdefault:\" + eventName)) {\n      ev.preventDefault();\n    }\n    if (element.hasAttribute(\"stoppropagation:\" + eventName)) {\n      ev.stopPropagation();\n    }\n    const ctx = element._qc_;\n    const relevantListeners = ctx && ctx.li.filter((li) => li[0] === attrName);\n    if (relevantListeners && relevantListeners.length > 0) {\n      for (const listener of relevantListeners) {\n        const results = listener[1].getFn([element, ev], () => element.isConnected)(ev, element);\n        const cancelBubble = ev.cancelBubble;\n        if (isPromise(results)) {\n          await results;\n        }\n        if (cancelBubble) {\n          ev.stopPropagation();\n        }\n      }\n      return;\n    }\n    const attrValue = element.getAttribute(attrName);\n    if (attrValue) {\n      const container = element.closest(\"[q\\\\:container]\");\n      const qBase = container.getAttribute(\"q:base\");\n      const qVersion = container.getAttribute(\"q:version\") || \"unknown\";\n      const qManifest = container.getAttribute(\"q:manifest-hash\") || \"dev\";\n      const base = new URL(qBase, doc.baseURI);\n      for (const qrl of attrValue.split(\"\\n\")) {\n        const url = new URL(qrl, base);\n        const href = url.href;\n        const symbol = url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\n        const reqTime = performance.now();\n        let handler;\n        let importError;\n        let error;\n        const isSync = qrl.startsWith(\"#\");\n        const eventData = {\n          qBase,\n          qManifest,\n          qVersion,\n          href,\n          symbol,\n          element,\n          reqTime\n        };\n        if (isSync) {\n          const hash = container.getAttribute(\"q:instance\");\n          handler = (doc[\"qFuncs_\" + hash] || [])[Number.parseInt(symbol)];\n          if (!handler) {\n            importError = \"sync\";\n            error = new Error(\"sym:\" + symbol);\n          }\n        } else {\n          emitEvent(\"qsymbol\", eventData);\n          const uri = url.href.split(\"#\")[0];\n          try {\n            const module = import(\n                            uri\n            );\n            resolveContainer(container);\n            handler = (await module)[symbol];\n            if (!handler) {\n              importError = \"no-symbol\";\n              error = new Error(`${symbol} not in ${uri}`);\n            }\n          } catch (err) {\n            importError || (importError = \"async\");\n            error = err;\n          }\n        }\n        if (!handler) {\n          emitEvent(\"qerror\", {\n            importError,\n            error,\n            ...eventData\n          });\n          console.error(error);\n          break;\n        }\n        const previousCtx = doc.__q_context__;\n        if (element.isConnected) {\n          try {\n            doc.__q_context__ = [element, ev, url];\n            const results = handler(ev, element);\n            if (isPromise(results)) {\n              await results;\n            }\n          } catch (error2) {\n            emitEvent(\"qerror\", { error: error2, ...eventData });\n          } finally {\n            doc.__q_context__ = previousCtx;\n          }\n        }\n      }\n    }\n  };\n  const emitEvent = (eventName, detail) => {\n    doc.dispatchEvent(createEvent(eventName, detail));\n  };\n  const camelToKebab = (str) => str.replace(/([A-Z])/g, (a) => \"-\" + a.toLowerCase());\n  const processDocumentEvent = async (ev) => {\n    let type = camelToKebab(ev.type);\n    let element = ev.target;\n    broadcast(\"-document\", ev, type);\n    while (element && element.getAttribute) {\n      const results = dispatch(element, \"\", ev, type);\n      let cancelBubble = ev.cancelBubble;\n      if (isPromise(results)) {\n        await results;\n      }\n      cancelBubble = cancelBubble || ev.cancelBubble || element.hasAttribute(\"stoppropagation:\" + ev.type);\n      element = ev.bubbles && cancelBubble !== true ? element.parentElement : null;\n    }\n  };\n  const processWindowEvent = (ev) => {\n    broadcast(\"-window\", ev, camelToKebab(ev.type));\n  };\n  const processReadyStateChange = () => {\n    var _a;\n    const readyState = doc.readyState;\n    if (!hasInitialized && (readyState == \"interactive\" || readyState == \"complete\")) {\n      roots.forEach(findShadowRoots);\n      hasInitialized = 1;\n      emitEvent(\"qinit\");\n      const riC = (_a = win.requestIdleCallback) != null ? _a : win.setTimeout;\n      riC.bind(win)(() => emitEvent(\"qidle\"));\n      if (events.has(\"qvisible\")) {\n        const results = querySelectorAll(\"[on\\\\:qvisible]\");\n        const observer = new IntersectionObserver((entries) => {\n          for (const entry of entries) {\n            if (entry.isIntersecting) {\n              observer.unobserve(entry.target);\n              dispatch(entry.target, \"\", createEvent(\"qvisible\", entry));\n            }\n          }\n        });\n        results.forEach((el) => observer.observe(el));\n      }\n    }\n  };\n  const addEventListener = (el, eventName, handler, capture = false) => {\n    return el.addEventListener(eventName, handler, { capture, passive: false });\n  };\n  const processEventOrNode = (...eventNames) => {\n    for (const eventNameOrNode of eventNames) {\n      if (typeof eventNameOrNode === \"string\") {\n        if (!events.has(eventNameOrNode)) {\n          roots.forEach(\n            (root) => addEventListener(root, eventNameOrNode, processDocumentEvent, true)\n          );\n          addEventListener(win, eventNameOrNode, processWindowEvent, true);\n          events.add(eventNameOrNode);\n        }\n      } else {\n        if (!roots.has(eventNameOrNode)) {\n          events.forEach(\n            (eventName) => addEventListener(eventNameOrNode, eventName, processDocumentEvent, true)\n          );\n          roots.add(eventNameOrNode);\n        }\n      }\n    }\n  };\n  if (!(\"__q_context__\" in doc)) {\n    doc.__q_context__ = 0;\n    const qwikevents = win.qwikevents;\n    if (Array.isArray(qwikevents)) {\n      processEventOrNode(...qwikevents);\n    }\n    win.qwikevents = {\n      events,\n      roots,\n      push: processEventOrNode\n    };\n    addEventListener(doc, \"readystatechange\", processReadyStateChange);\n    processReadyStateChange();\n  }\n})()";
export { QWIK_LOADER, QWIK_LOADER_DEBUG };
