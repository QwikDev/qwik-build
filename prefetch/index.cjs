const QWIK_PREFETCH = "(()=>{const t=Number.MAX_SAFE_INTEGER>>>1;function n(n,i){const[o,s]=c(i),a=n.t.find((t=>o===t.i));if(a)return n.o(\"intercepting\",i.pathname),e(n,a,[s],t).then((()=>function(t,n){const e=t.u.find((t=>t.l.pathname===n.pathname));return e?e.h.then((t=>t.clone())):(t.o(\"CACHE HIT\",n.pathname),t.$(n))}(n,i)))}async function e(n,e,o,c){const a=new Set;o.forEach((t=>s(e.p,a,t))),await Promise.all(Array.from(a).map((i=>async function(n,e,i){let o=n.u.find((t=>t.l.pathname===e.pathname));const s=i>=t?\"direct\":\"prefetch\";if(o){const t=o.m?\"fetching\":\"waiting\";o.v<i?(n.o(\"queue update priority\",t,e.pathname),o.v=i):n.o(\"already in queue\",s,t,e.pathname)}else await n.$(e)||(n.o(\"enqueue\",s,e.pathname),o={v:i,l:e,C:null,h:null,m:!1},o.h=new Promise((t=>o.C=t)),n.u.push(o));return o}(n,new URL(e.i+i,n.l),c)))),i(n)}function i(n){n.u.sort(o);let e=0;for(const o of n.u)if(o.m)e++;else if(n.T()&&(e<n.H||o.v>=t)){o.m=!0,e++;const s=o.v>=t?\"FETCH (CACHE MISS)\":\"FETCH\";n.o(s,o.l.pathname),n.R(o.l).then((async t=>{o.C(t),200===t.status&&(n.o(\"CACHED\",o.l.pathname),await n.S(o.l,t.clone()))})).finally((()=>{n.o(\"FETCH DONE\",o.l.pathname),n.u.splice(n.u.indexOf(o),1),i(n)}))}}function o(t,n){return n.v-t.v}function s(t,n,e){if(!n.has(e)){n.add(e);let i=t.findIndex((t=>t===e));if(-1!==i)for(;\"number\"==typeof t[++i];)s(t,n,t[t[i]])}return n}function c(t){const n=new URL(t).pathname,e=n.lastIndexOf(\"/\");return[n.substring(0,e+1),n.substring(e+1)]}const a=(...t)=>{console.log(\"⚙️ Prefetch SW:\",...t)};async function r(t,n,e,i){const o=t.t.findIndex((t=>t==t));if(-1!==o&&t.t.splice(o,1),t.o(\"adding base:\",n),t.t.push({i:n,p:e}),i){const i=new Set(e.filter((t=>\"string\"==typeof t))),o=await t.T();if(o)for(const e of await o.keys()){const[s,a]=c(new URL(e.url)),r=[];s!==n||i.has(a)||(t.o(\"deleting\",e.url),r.push(o.delete(e))),await Promise.all(r)}}}function u(t,n,i){const o=t.t.find((t=>n===t.i));o?e(t,o,i,0):console.error(`Base path not found: ${n}, ignoring prefetch.`)}function f(t){if(!t.U&&t.L.length){const e=t.L.shift();t.U=(async(t,e)=>{const i=e[0];t.o(\"received message:\",i,e[1],e.slice(2)),\"graph\"===i?await r(t,e[1],e.slice(2),!0):\"graph-url\"===i?await async function(t,e,i){await r(t,e,[],!1);const o=await n(t,new URL(e+i,t.l));if(o&&200===o.status){const n=await o.json();n.push(i),await r(t,e,n,!0)}}(t,e[1],e[2]):\"prefetch\"===i?await u(t,e[1],e.slice(2)):\"prefetch-all\"===i?await function(t,n){const e=t.t.find((t=>n===t.i));e?u(t,n,e.p.filter((t=>\"string\"==typeof t))):console.error(`Base path not found: ${n}, ignoring prefetch.`)}(t,e[1]):\"ping\"===i?a(\"ping\"):\"verbose\"===i?(t.o=a)(\"mode: verbose\"):console.error(\"UNKNOWN MESSAGE:\",e)})(t,e).then((()=>{f(t)}))}}class l{constructor(t,n,e=10,i=null,o=null,s=[],c=[],a=[]){this.R=t,this.l=n,this.H=e,this.A=i,this.U=o,this.u=s,this.t=c,this.L=a}T(){return this.A}async S(t,n){const e=await this.T();return null==e?void 0:e.put(t,n)}async $(t){const n=await this.T();return null==n?void 0:n.match(t)}o(){}}(t=>{const e=(i=t.fetch.bind(t),o=new URL(t.location.href),new l(i,o));var i,o;e.T=()=>e.A?e.A:(clearTimeout(void 0),setTimeout((()=>{e.A=null}),5e3),t.caches.open(\"QwikBundles\")),t.addEventListener(\"fetch\",(t=>{const i=t.request;if(\"GET\"===i.method){const o=n(e,new URL(i.url));o&&t.respondWith(o)}})),t.addEventListener(\"message\",(t=>{e.L.push(t.data),f(e)})),t.addEventListener(\"install\",(()=>{t.skipWaiting()})),t.addEventListener(\"activate\",(n=>{e.T=()=>e.A?e.A:(clearTimeout(void 0),setTimeout((()=>{e.A=null}),5e3),t.caches.open(\"QwikBundles\")),n.waitUntil(t.clients.claim())}))})(globalThis)})();";
const QWIK_PREFETCH_DEBUG = "(() => {\n    const DIRECT_PRIORITY = Number.MAX_SAFE_INTEGER >>> 1;\n    function directFetch(swState, url) {\n        const [basePath, filename] = parseBaseFilename(url);\n        const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n        if (base) {\n            swState.$log$(\"intercepting\", url.pathname);\n            return enqueueFileAndDependencies(swState, base, [ filename ], DIRECT_PRIORITY).then((() => function(swState, url) {\n                const currentRequestTask = swState.$queue$.find((task => task.$url$.pathname === url.pathname));\n                if (currentRequestTask) {\n                    return currentRequestTask.$response$.then((response => response.clone()));\n                }\n                swState.$log$(\"CACHE HIT\", url.pathname);\n                return swState.$match$(url);\n            }(swState, url)));\n        }\n    }\n    async function enqueueFileAndDependencies(swState, base, filenames, priority) {\n        const fetchSet =  new Set;\n        filenames.forEach((filename => addDependencies(base.$graph$, fetchSet, filename)));\n        await Promise.all(Array.from(fetchSet).map((filename => async function(swState, url, priority) {\n            let task = swState.$queue$.find((task2 => task2.$url$.pathname === url.pathname));\n            const mode = priority >= DIRECT_PRIORITY ? \"direct\" : \"prefetch\";\n            if (task) {\n                const state = task.$isFetching$ ? \"fetching\" : \"waiting\";\n                if (task.$priority$ < priority) {\n                    swState.$log$(\"queue update priority\", state, url.pathname);\n                    task.$priority$ = priority;\n                } else {\n                    swState.$log$(\"already in queue\", mode, state, url.pathname);\n                }\n            } else {\n                if (!await swState.$match$(url)) {\n                    swState.$log$(\"enqueue\", mode, url.pathname);\n                    task = {\n                        $priority$: priority,\n                        $url$: url,\n                        $resolveResponse$: null,\n                        $response$: null,\n                        $isFetching$: !1\n                    };\n                    task.$response$ = new Promise((resolve => task.$resolveResponse$ = resolve));\n                    swState.$queue$.push(task);\n                }\n            }\n            return task;\n        }(swState, new URL(base.$path$ + filename, swState.$url$), priority))));\n        taskTick(swState);\n    }\n    function taskTick(swState) {\n        swState.$queue$.sort(byFetchOrder);\n        let outstandingRequests = 0;\n        for (const task of swState.$queue$) {\n            if (task.$isFetching$) {\n                outstandingRequests++;\n            } else if (swState.$getCache$() && (outstandingRequests < swState.$maxPrefetchRequests$ || task.$priority$ >= DIRECT_PRIORITY)) {\n                task.$isFetching$ = !0;\n                outstandingRequests++;\n                const action = task.$priority$ >= DIRECT_PRIORITY ? \"FETCH (CACHE MISS)\" : \"FETCH\";\n                swState.$log$(action, task.$url$.pathname);\n                swState.$fetch$(task.$url$).then((async response => {\n                    task.$resolveResponse$(response);\n                    if (200 === response.status) {\n                        swState.$log$(\"CACHED\", task.$url$.pathname);\n                        await swState.$put$(task.$url$, response.clone());\n                    }\n                })).finally((() => {\n                    swState.$log$(\"FETCH DONE\", task.$url$.pathname);\n                    swState.$queue$.splice(swState.$queue$.indexOf(task), 1);\n                    taskTick(swState);\n                }));\n            }\n        }\n    }\n    function byFetchOrder(a, b) {\n        return b.$priority$ - a.$priority$;\n    }\n    function addDependencies(graph, fetchSet, filename) {\n        if (!fetchSet.has(filename)) {\n            fetchSet.add(filename);\n            let index = graph.findIndex((file => file === filename));\n            if (-1 !== index) {\n                while (\"number\" == typeof graph[++index]) {\n                    addDependencies(graph, fetchSet, graph[graph[index]]);\n                }\n            }\n        }\n        return fetchSet;\n    }\n    function parseBaseFilename(url) {\n        const pathname = new URL(url).pathname;\n        const slashIndex = pathname.lastIndexOf(\"/\");\n        return [ pathname.substring(0, slashIndex + 1), pathname.substring(slashIndex + 1) ];\n    }\n    const log = (...args) => {\n        console.log(\"⚙️ Prefetch SW:\", ...args);\n    };\n    const processMessage = async (state, msg) => {\n        const type = msg[0];\n        state.$log$(\"received message:\", type, msg[1], msg.slice(2));\n        \"graph\" === type ? await processBundleGraph(state, msg[1], msg.slice(2), !0) : \"graph-url\" === type ? await async function(swState, base, graphPath) {\n            await processBundleGraph(swState, base, [], !1);\n            const response = await directFetch(swState, new URL(base + graphPath, swState.$url$));\n            if (response && 200 === response.status) {\n                const graph = await response.json();\n                graph.push(graphPath);\n                await processBundleGraph(swState, base, graph, !0);\n            }\n        }(state, msg[1], msg[2]) : \"prefetch\" === type ? await processPrefetch(state, msg[1], msg.slice(2)) : \"prefetch-all\" === type ? await function(swState, basePath) {\n            const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n            base ? processPrefetch(swState, basePath, base.$graph$.filter((item => \"string\" == typeof item))) : console.error(`Base path not found: ${basePath}, ignoring prefetch.`);\n        }(state, msg[1]) : \"ping\" === type ? log(\"ping\") : \"verbose\" === type ? (state.$log$ = log)(\"mode: verbose\") : console.error(\"UNKNOWN MESSAGE:\", msg);\n    };\n    async function processBundleGraph(swState, base, graph, cleanup) {\n        const existingBaseIndex = swState.$bases$.findIndex((base2 => base2 == base2));\n        -1 !== existingBaseIndex && swState.$bases$.splice(existingBaseIndex, 1);\n        swState.$log$(\"adding base:\", base);\n        swState.$bases$.push({\n            $path$: base,\n            $graph$: graph\n        });\n        if (cleanup) {\n            const bundles = new Set(graph.filter((item => \"string\" == typeof item)));\n            const cache = await swState.$getCache$();\n            if (cache) {\n                for (const request of await cache.keys()) {\n                    const [cacheBase, filename] = parseBaseFilename(new URL(request.url));\n                    const promises = [];\n                    if (cacheBase === base && !bundles.has(filename)) {\n                        swState.$log$(\"deleting\", request.url);\n                        promises.push(cache.delete(request));\n                    }\n                    await Promise.all(promises);\n                }\n            }\n        }\n    }\n    function processPrefetch(swState, basePath, bundles) {\n        const base = swState.$bases$.find((base2 => basePath === base2.$path$));\n        base ? enqueueFileAndDependencies(swState, base, bundles, 0) : console.error(`Base path not found: ${basePath}, ignoring prefetch.`);\n    }\n    function drainMsgQueue(swState) {\n        if (!swState.$msgQueuePromise$ && swState.$msgQueue$.length) {\n            const top = swState.$msgQueue$.shift();\n            swState.$msgQueuePromise$ = processMessage(swState, top).then((() => {\n                drainMsgQueue(swState);\n            }));\n        }\n    }\n    class SWStateImpl {\n        constructor($fetch$, $url$, $maxPrefetchRequests$ = 10, $cache$ = null, $msgQueuePromise$ = null, $queue$ = [], $bases$ = [], $msgQueue$ = []) {\n            this.$fetch$ = $fetch$;\n            this.$url$ = $url$;\n            this.$maxPrefetchRequests$ = $maxPrefetchRequests$;\n            this.$cache$ = $cache$;\n            this.$msgQueuePromise$ = $msgQueuePromise$;\n            this.$queue$ = $queue$;\n            this.$bases$ = $bases$;\n            this.$msgQueue$ = $msgQueue$;\n        }\n        $getCache$() {\n            return this.$cache$;\n        }\n        async $put$(request, response) {\n            const cache = await this.$getCache$();\n            return null == cache ? void 0 : cache.put(request, response);\n        }\n        async $match$(request) {\n            const cache = await this.$getCache$();\n            return null == cache ? void 0 : cache.match(request);\n        }\n        $log$() {}\n    }\n    (swScope => {\n        const swState = ((fetch, url) => new SWStateImpl(fetch, url))(swScope.fetch.bind(swScope), new URL(swScope.location.href));\n        swState.$getCache$ = () => {\n            if (swState.$cache$) {\n                return swState.$cache$;\n            }\n            clearTimeout(undefined);\n            setTimeout((() => {\n                swState.$cache$ = null;\n            }), 5e3);\n            return swScope.caches.open(\"QwikBundles\");\n        };\n        swScope.addEventListener(\"fetch\", (ev => {\n            const request = ev.request;\n            if (\"GET\" === request.method) {\n                const response = directFetch(swState, new URL(request.url));\n                response && ev.respondWith(response);\n            }\n        }));\n        swScope.addEventListener(\"message\", (ev => {\n            swState.$msgQueue$.push(ev.data);\n            drainMsgQueue(swState);\n        }));\n        swScope.addEventListener(\"install\", (() => {\n            swScope.skipWaiting();\n        }));\n        swScope.addEventListener(\"activate\", (event => {\n            swState.$getCache$ = () => {\n                if (swState.$cache$) {\n                    return swState.$cache$;\n                }\n                clearTimeout(undefined);\n                setTimeout((() => {\n                    swState.$cache$ = null;\n                }), 5e3);\n                return swScope.caches.open(\"QwikBundles\");\n            };\n            event.waitUntil(swScope.clients.claim());\n        }));\n    })(globalThis);\n})();";
exports.QWIK_PREFETCH = QWIK_PREFETCH;
exports.QWIK_PREFETCH_DEBUG = QWIK_PREFETCH_DEBUG;
